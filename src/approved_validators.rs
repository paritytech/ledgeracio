// Copyright 2020 Parity Technologies (UK) Ltd.
// This file is part of ledgeracio.
//
// ledgeracio is free software: you can redistribute it and/or modify it under
// the terms of the GNU General Public License as published by the Free Software
// Foundation, either version 3 of the License, or (at your option) any later
// version.
//
// ledgeracio is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with ledgeracio.  If not, see <http://www.gnu.org/licenses/>.

//! Routines for handling approved validators

use super::{Error, StructOpt};
use crate::{AccountId, Ss58AddressFormat};
use std::{os::unix::ffi::OsStrExt, path::PathBuf};

#[derive(StructOpt, Debug)]
pub(crate) enum ACL {
    /// Upload a new approved validator list.  This list must be signed.
    Upload { path: PathBuf },
    /// Set the validator list signing key.  This will fail if a signing key has
    /// already been set.
    SetKey {
        #[structopt(parse(try_from_str = hex::FromHex::from_hex))]
        key: [u8; 32],
    },
    /// Get the validator list signing key.  This will fail unless a signing key
    /// has been set.
    GetKey,
    /// Generate a new signing key.
    GenKey {
        /// File to write the public key to.  This must have the extension
        /// `.pub`.
        ///
        /// The public key can (and should) be freely distributed.
        #[structopt(short = "p", long = "public")]
        public: PathBuf,
        /// File to write the secret key to.  This must end with `.sec`.
        /// Furthermore, all but the last four bytes of the public and
        /// secret key filenames must be identical.
        ///
        /// This file will be created with 0o600 permissions (read and write for
        /// owner only), and its contents must be kept secret.  Anyone
        /// who can read this file can sign allowlists.
        #[structopt(short = "s", long = "secret")]
        secret: PathBuf,
    },
    /// Compile the provided textual allowlist into a binary format and sign it.
    ///
    /// `secret` should be a secret signing key generated by `ledgeracio
    /// allowlist genkey`.  If you provide a public key, it will be verified
    /// to match the provided secret key.  This helps check that neither has
    /// been corrupted, and that you are using the correct secret key.
    Sign {
        /// The textual allowlist file.
        ///
        /// The textual allowlist format is very simple.  If a line is empty, or
        /// if its first non-whitespace character is `;` or `#`, it is
        /// considered a comment.  Otherwise, the line must be a valid SS58
        /// address for the provided network, except that leading and
        /// trailing whitespace are ignored.  The process of compiling
        /// an allowlist to binary format and signing it is completely
        /// deterministic.
        #[structopt(short = "f", long = "file")]
        file: PathBuf,
        /// The secret key file.
        #[structopt(short = "s", long = "secret")]
        secret: PathBuf,
        /// The public key file.  Optional, but strongly recommended.
        #[structopt(short = "p", long = "public")]
        public: Option<PathBuf>,
        /// The output file
        #[structopt(short = "o", long = "output")]
        output: PathBuf,
    },
    /// Inspect the given allowlist file and verify its signature. The output is
    /// in a format suitable for `ledgeracio sign`.
    Inspect {
        /// The binary allowlist file to read
        #[structopt(short = "f", long = "file")]
        file: PathBuf,
        /// The public key file.
        #[structopt(short = "p", long = "public")]
        public: PathBuf,
        /* /// The output file
         *  #[structopt(short = "o", long = "output")]
         * output: PathBuf, */
    },
}

fn write(buf: &[u8], path: &std::path::Path) -> std::io::Result<()> {
    use std::{fs::OpenOptions, io::Write, os::unix::fs::OpenOptionsExt};
    OpenOptions::new()
        .mode(0o400)
        .write(true)
        .create(true)
        .truncate(true)
        .open(path)?
        .write_all(buf)
}

pub(crate) async fn main<T: FnOnce() -> Result<super::HardStore, Error>>(
    acl: ACL,
    hardware: T,
    network: Ss58AddressFormat,
) -> Result<(), Error> {
    use ed25519_dalek::Keypair;

    match acl {
        ACL::GetKey => {
            let s = hardware()?.get_pubkey().await?;
            println!("Public key is {}", hex::encode(s));
            Ok(())
        }
        ACL::SetKey { key } => hardware()?.set_pubkey(&key).await,
        ACL::Upload { path } => {
            let allowlist = std::fs::read(path)?;
            hardware()?.allowlist_upload(&allowlist).await
        }
        ACL::GenKey { public, secret } => {
            let pub_bytes = public.as_os_str().as_bytes();
            let sec_bytes = secret.as_os_str().as_bytes();
            let len = pub_bytes.len();
            if !pub_bytes.ends_with(b".pub")
                || !sec_bytes.ends_with(b".sec")
                || len != sec_bytes.len()
                || pub_bytes[..len - 4] != sec_bytes[..len - 4]
            {
                return Err(
                    "Public and secret key filenames must match, except that the public key file \
                     must have extension .pub and secret key file must have extension .sec"
                        .to_owned()
                        .into(),
                )
            }
            let keypair = Keypair::generate(&mut rand::rngs::OsRng {});
            let secretkey = keypair.secret.to_bytes();
            let publickey = keypair.public.to_bytes();
            write(&publickey, &public)?;
            write(&secretkey, &secret)?;
            Ok(())
        }
        ACL::Sign {
            file,
            public,
            secret,
            output,
        } => {
            let file = std::io::BufReader::new(std::fs::File::open(file)?);
            let public = match public {
                None => None,
                Some(public) => Some(ed25519_dalek::PublicKey::from_bytes(&*std::fs::read(
                    public,
                )?)?),
            };
            let secret: Vec<u8> = std::fs::read(secret)?;
            let sk = (&ed25519_dalek::SecretKey::from_bytes(&*secret)?).into();
            let signed =
                crate::parser::parse::<_, AccountId>(file, network, public.as_ref(), Some(&sk))?;
            std::fs::write(output, signed)?;
            Ok(())
        }
        ACL::Inspect { file, public } => {
            let file = std::io::BufReader::new(std::fs::File::open(file)?);
            let pk = ed25519_dalek::PublicKey::from_bytes(&*std::fs::read(public)?)?;
            for i in crate::parser::inspect::<_, AccountId>(file, network, &pk)? {
                println!("{}", i);
            }
            Ok(())
        }
    }
}
